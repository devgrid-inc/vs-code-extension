import { describe, it, expect, vi, beforeEach } from 'vitest';

import type { IGraphQLClient } from '../../interfaces/IGraphQLClient';
import type { ILogger } from '../../interfaces/ILogger';
import { VulnerabilityService } from '../../services/VulnerabilityService';

describe('VulnerabilityService', () => {
  let vulnerabilityService: VulnerabilityService;
  let mockLogger: ILogger;
  let mockGraphQLClient: IGraphQLClient;

  beforeEach(() => {
    mockLogger = {
      trace: vi.fn(),
      debug: vi.fn(),
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      setLevel: vi.fn(),
      getLevel: vi.fn().mockReturnValue('info'),
      child: vi.fn().mockReturnThis(),
    };

    mockGraphQLClient = {
      query: vi.fn(),
      mutate: vi.fn(),
      setEndpoint: vi.fn(),
      setAuthToken: vi.fn(),
    };

    vulnerabilityService = new VulnerabilityService(mockGraphQLClient, mockLogger, 100);
  });

    describe('API Response Validation', () => {
      it('should validate that vulnerabilities have required ID field', async () => {
        const vulnerabilitiesWithIds = [
          {
            id: 'vuln-1',
            name: 'Vulnerability with ID',
            severity: 'HIGH',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-1',
          },
          {
            id: 'vuln-2',
            name: 'Another vulnerability with ID',
            severity: 'CRITICAL',
            status: 'open',
            packageName: 'other-package',
            versionRange: '2.0.0',
            publishedAt: '2023-01-02',
            referenceUrl: 'https://example.com/vuln-2',
          },
        ];

        (mockGraphQLClient.query as any).mockResolvedValue({
          data: {
            vulnerabilities: {
              items: vulnerabilitiesWithIds,
            },
          },
        });

        const result = await vulnerabilityService.fetchVulnerabilities('component-1');

        expect(result).toHaveLength(2);
        expect(result[0].id).toBe('vuln-1');
        expect(result[1].id).toBe('vuln-2');
        expect(result.every(v => v.id)).toBe(true);
      });

      it('should filter out vulnerabilities with missing ID', async () => {
        const vulnerabilitiesWithMissingIds = [
          {
            id: 'vuln-1',
            name: 'Valid vulnerability',
            severity: 'HIGH',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-1',
          },
          {
            id: null,
            name: 'Vulnerability with null ID',
            severity: 'MEDIUM',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-2',
          },
          {
            id: undefined,
            name: 'Vulnerability with undefined ID',
            severity: 'LOW',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-3',
          },
          {
            name: 'Vulnerability missing ID field entirely',
            severity: 'LOW',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-4',
          },
        ];

        (mockGraphQLClient.query as any).mockResolvedValue({
          data: {
            vulnerabilities: {
              items: vulnerabilitiesWithMissingIds,
            },
          },
        });

        const result = await vulnerabilityService.fetchVulnerabilities('component-1');

        // Should only return the one vulnerability with a valid ID
        expect(result).toHaveLength(1);
        expect(result[0].id).toBe('vuln-1');
      });

      it('should filter out vulnerabilities with missing name/title', async () => {
        const vulnerabilitiesWithMissingNames = [
          {
            id: 'vuln-1',
            name: 'Valid vulnerability',
            severity: 'HIGH',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-1',
          },
          {
            id: 'vuln-2',
            name: null,
            severity: 'MEDIUM',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-2',
          },
          {
            id: 'vuln-3',
            name: undefined,
            severity: 'LOW',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-3',
          },
          {
            id: 'vuln-4',
            severity: 'LOW',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-4',
            // Missing name field entirely
          },
        ];

        (mockGraphQLClient.query as any).mockResolvedValue({
          data: {
            vulnerabilities: {
              items: vulnerabilitiesWithMissingNames,
            },
          },
        });

        const result = await vulnerabilityService.fetchVulnerabilities('component-1');

        // Should only return the one vulnerability with a valid name
        expect(result).toHaveLength(1);
        expect(result[0].id).toBe('vuln-1');
        expect(result[0].title).toBe('Valid vulnerability');
      });

      it('should filter out vulnerabilities with missing severity', async () => {
        const vulnerabilitiesWithMissingSeverity = [
          {
            id: 'vuln-1',
            name: 'Valid vulnerability',
            severity: 'HIGH',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-1',
          },
          {
            id: 'vuln-2',
            name: 'Vulnerability with null severity',
            severity: null,
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-2',
          },
          {
            id: 'vuln-3',
            name: 'Vulnerability with undefined severity',
            severity: undefined,
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-3',
          },
          {
            id: 'vuln-4',
            name: 'Vulnerability missing severity field',
            status: 'open',
            packageName: 'test-package',
            versionRange: '1.0.0',
            publishedAt: '2023-01-01',
            referenceUrl: 'https://example.com/vuln-4',
            // Missing severity field entirely
          },
        ];

        (mockGraphQLClient.query as any).mockResolvedValue({
          data: {
            vulnerabilities: {
              items: vulnerabilitiesWithMissingSeverity,
            },
          },
        });

        const result = await vulnerabilityService.fetchVulnerabilities('component-1');

        // Should only return the one vulnerability with a valid severity
        expect(result).toHaveLength(1);
        expect(result[0].id).toBe('vuln-1');
        expect(result[0].severity).toBe('HIGH');
      });
    });

    describe('fetchVulnerabilities', () => {
    it('should fetch vulnerabilities for component and repository', async () => {
      const componentVulns = [
        {
          id: 'vuln-1',
          name: 'Component Vulnerability',
          severity: 'HIGH',
          status: 'open',
          packageName: 'test-package',
          versionRange: '1.0.0',
          publishedAt: '2023-01-01',
          referenceUrl: 'https://example.com/vuln-1',
        },
      ];

      const repoVulns = [
        {
          id: 'vuln-2',
          name: 'Repository Vulnerability',
          severity: 'CRITICAL',
          status: 'open',
          packageName: 'other-package',
          versionRange: '2.0.0',
          publishedAt: '2023-01-02',
          referenceUrl: 'https://example.com/vuln-2',
        },
      ];

      (mockGraphQLClient.query as any)
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: componentVulns,
            },
          },
        })
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: repoVulns,
            },
          },
        });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1', 'repo-1');

      expect(result).toHaveLength(2);
      expect(result[0]).toEqual({
        id: 'vuln-1',
        title: 'Component Vulnerability',
        severity: 'HIGH',
        status: 'open',
        packageName: undefined,
        versionRange: undefined,
        publishedAt: undefined,
        referenceUrl: undefined,
      });
      expect(result[1]).toEqual({
        id: 'vuln-2',
        title: 'Repository Vulnerability',
        severity: 'CRITICAL',
        status: 'open',
        packageName: undefined,
        versionRange: undefined,
        publishedAt: undefined,
        referenceUrl: undefined,
      });
    });

    it('should deduplicate vulnerabilities by ID', async () => {
      const componentVulns = [
        {
          id: 'vuln-1',
          title: 'Duplicate Vulnerability',
          severity: 'HIGH',
          status: 'open',
          packageName: 'test-package',
          versionRange: '1.0.0',
          publishedAt: '2023-01-01',
          referenceUrl: 'https://example.com/vuln-1',
        },
      ];

      const repoVulns = [
        {
          id: 'vuln-1', // Same ID as component vuln
          name: 'Duplicate Vulnerability',
          severity: 'HIGH',
          status: 'open',
          packageName: 'test-package',
          versionRange: '1.0.0',
          publishedAt: '2023-01-01',
          referenceUrl: 'https://example.com/vuln-1',
        },
      ];

      (mockGraphQLClient.query as any)
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: componentVulns,
            },
          },
        })
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: repoVulns,
            },
          },
        });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1', 'repo-1');

      expect(result).toHaveLength(1);
      expect(result[0].id).toBe('vuln-1');
    });

    it('should handle empty results', async () => {
      (mockGraphQLClient.query as any).mockResolvedValue({
        data: {
          vulnerabilities: {
            items: [],
          },
        },
      });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1', 'repo-1');

      expect(result).toHaveLength(0);
    });

    it('should respect maxItems limit', async () => {
      const manyVulns = Array.from({ length: 150 }, (_, i) => ({
        id: `vuln-${i}`,
        name: `Vulnerability ${i}`,
        severity: 'HIGH',
        status: 'open',
        packageName: 'test-package',
        versionRange: '1.0.0',
        publishedAt: '2023-01-01',
        referenceUrl: 'https://example.com/vuln',
      }));

      (mockGraphQLClient.query as any).mockResolvedValue({
        data: {
          vulnerabilities: {
            items: manyVulns,
          },
        },
      });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1');

      expect(result).toHaveLength(100); // Should be limited to maxItems
    });

    describe('Parameter Validation', () => {
      it('should log parameter details when called', async () => {
        const vulnId = 'test-vuln-123';

        (mockGraphQLClient.query as any).mockResolvedValueOnce({
          data: { vulnerability: null }
        });

        await vulnerabilityService.fetchVulnerabilityDetails(vulnId);

        expect(mockLogger.info).toHaveBeenCalledWith('fetchVulnerabilityDetails called', {
          id: vulnId,
          idType: 'string',
          idValue: vulnId,
        });
      });

      it('should handle undefined ID parameter', async () => {
        const vulnId = undefined as any;

        (mockGraphQLClient.query as any).mockResolvedValue({
          data: { vulnerability: null }
        });

        await vulnerabilityService.fetchVulnerabilityDetails(vulnId);

        expect(mockLogger.info).toHaveBeenCalledWith('fetchVulnerabilityDetails called', {
          id: undefined,
          idType: 'undefined',
          idValue: undefined,
        });
      });

      it('should handle null ID parameter', async () => {
        const vulnId = null as any;

        (mockGraphQLClient.query as any).mockResolvedValue({
          data: { vulnerability: null }
        });

        await vulnerabilityService.fetchVulnerabilityDetails(vulnId);

        expect(mockLogger.info).toHaveBeenCalledWith('fetchVulnerabilityDetails called', {
          id: null,
          idType: 'object',
          idValue: null,
        });
      });

      it('should handle empty string ID parameter', async () => {
        const vulnId = '';

        (mockGraphQLClient.query as any).mockResolvedValue({
          data: { vulnerability: null }
        });

        await vulnerabilityService.fetchVulnerabilityDetails(vulnId);

        expect(mockLogger.info).toHaveBeenCalledWith('fetchVulnerabilityDetails called', {
          id: '',
          idType: 'string',
          idValue: '',
        });
      });
    });

    describe('fetchVulnerabilityDetails', () => {
      it('should fetch vulnerability details successfully', async () => {
        const mockVulnerability = {
          id: 'test-vuln-1',
          name: 'Test Vulnerability',
          description: 'This is a test vulnerability description.',
          severity: 'HIGH',
          status: 'open',
          originatingSystemUrl: 'https://cve.example.com/CVE-2023-12345',
          identifiers: [
            {
              id: 'ident-1',
              externalSource: 'CVE',
              externalId: 'CVE-2023-12345',
              externalUrl: 'https://cve.example.com/CVE-2023-12345',
              externalName: 'Test Vulnerability',
              externalDescription: 'This is a test vulnerability description.',
              publishedDate: '2023-01-01T00:00:00Z',
              cvssScore: 7.5,
              vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
              references: []
            }
          ]
        };

        (mockGraphQLClient.query as any).mockResolvedValueOnce({
          data: {
            vulnerability: mockVulnerability
          }
        });

        const result = await vulnerabilityService.fetchVulnerabilityDetails('test-vuln-1');

        expect(result).toMatchObject({
          id: 'test-vuln-1',
          title: 'Test Vulnerability',
          severity: 'HIGH',
          status: 'open',
          packageName: undefined,
          versionRange: undefined,
          publishedAt: '2023-01-01T00:00:00Z',
          referenceUrl: 'https://cve.example.com/CVE-2023-12345',
          originatingSystemUrl: 'https://cve.example.com/CVE-2023-12345',
          identifiers: [
            { type: 'CVE', value: 'CVE-2023-12345', url: 'https://cve.example.com/CVE-2023-12345' }
          ],
          cvss: { baseScore: 7.5, vector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N' },
          description: 'This is a test vulnerability description.',
          remediation: undefined,
          references: []
        });
      });

      it('should return cached results for repeated requests', async () => {
        const mockVulnerability = {
          id: 'cached-vuln',
          name: 'Cached Vulnerability',
          description: null,
          severity: 'MEDIUM',
          status: 'open',
          originatingSystemUrl: null,
          identifiers: [
            {
              id: 'ident-1',
              externalSource: 'CVE',
              externalId: 'CVE-2023-99999',
              externalUrl: null,
              externalName: 'Cached Vulnerability',
              externalDescription: null,
              publishedDate: null,
              cvssScore: null,
              vectorString: null,
              references: []
            }
          ]
        };

        (mockGraphQLClient.query as any).mockResolvedValueOnce({
          data: { vulnerability: mockVulnerability }
        });

        // First call should fetch from API
        const result1 = await vulnerabilityService.fetchVulnerabilityDetails('cached-vuln');
        expect(result1?.title).toBe('Cached Vulnerability');

        // Second call should return cached result without API call
        const result2 = await vulnerabilityService.fetchVulnerabilityDetails('cached-vuln');
        expect(result2?.title).toBe('Cached Vulnerability');

        // Should only have been called once
        expect(mockGraphQLClient.query).toHaveBeenCalledTimes(1);
      });

      it('should return undefined for non-existent vulnerability', async () => {
        // Mock vulnerability query to return null (vulnerability not found)
        (mockGraphQLClient.query as any).mockResolvedValueOnce({
          data: { vulnerability: null }
        });

        const result = await vulnerabilityService.fetchVulnerabilityDetails('non-existent');
        expect(result).toBeUndefined();
      });

      it('should handle GraphQL errors', async () => {
        (mockGraphQLClient.query as any).mockRejectedValueOnce(new Error('GraphQL error'));

        await expect(vulnerabilityService.fetchVulnerabilityDetails('error-vuln'))
          .rejects.toThrow('Failed to fetch vulnerability details');
      });
    });
  });
});
