import { describe, it, expect, vi, beforeEach } from 'vitest';
import { VulnerabilityService } from '../../services/VulnerabilityService';
import type { ILogger } from '../../interfaces/ILogger';
import type { IGraphQLClient } from '../../interfaces/IGraphQLClient';

describe('VulnerabilityService', () => {
  let vulnerabilityService: VulnerabilityService;
  let mockLogger: ILogger;
  let mockGraphQLClient: IGraphQLClient;

  beforeEach(() => {
    mockLogger = {
      trace: vi.fn(),
      debug: vi.fn(),
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      setLevel: vi.fn(),
      getLevel: vi.fn().mockReturnValue('info'),
      child: vi.fn().mockReturnThis(),
    };

    mockGraphQLClient = {
      query: vi.fn(),
      mutate: vi.fn(),
      setEndpoint: vi.fn(),
      setAuthToken: vi.fn(),
    };

    vulnerabilityService = new VulnerabilityService(mockGraphQLClient, mockLogger, 100);
  });

  describe('fetchVulnerabilities', () => {
    it('should fetch vulnerabilities for component and repository', async () => {
      const componentVulns = [
        {
          id: 'vuln-1',
          title: 'Component Vulnerability',
          severity: 'HIGH',
          status: 'open',
          packageName: 'test-package',
          versionRange: '1.0.0',
          publishedAt: '2023-01-01',
          referenceUrl: 'https://example.com/vuln-1',
        },
      ];

      const repoVulns = [
        {
          id: 'vuln-2',
          title: 'Repository Vulnerability',
          severity: 'CRITICAL',
          status: 'open',
          packageName: 'other-package',
          versionRange: '2.0.0',
          publishedAt: '2023-01-02',
          referenceUrl: 'https://example.com/vuln-2',
        },
      ];

      (mockGraphQLClient.query as any)
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: componentVulns,
            },
          },
        })
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: repoVulns,
            },
          },
        });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1', 'repo-1');

      expect(result).toHaveLength(2);
      expect(result[0]).toEqual({
        id: 'vuln-1',
        title: 'Component Vulnerability',
        severity: 'HIGH',
        status: 'open',
        packageName: 'test-package',
        versionRange: '1.0.0',
        publishedAt: '2023-01-01',
        referenceUrl: 'https://example.com/vuln-1',
      });
      expect(result[1]).toEqual({
        id: 'vuln-2',
        title: 'Repository Vulnerability',
        severity: 'CRITICAL',
        status: 'open',
        packageName: 'other-package',
        versionRange: '2.0.0',
        publishedAt: '2023-01-02',
        referenceUrl: 'https://example.com/vuln-2',
      });
    });

    it('should deduplicate vulnerabilities by ID', async () => {
      const componentVulns = [
        {
          id: 'vuln-1',
          title: 'Duplicate Vulnerability',
          severity: 'HIGH',
          status: 'open',
          packageName: 'test-package',
          versionRange: '1.0.0',
          publishedAt: '2023-01-01',
          referenceUrl: 'https://example.com/vuln-1',
        },
      ];

      const repoVulns = [
        {
          id: 'vuln-1', // Same ID as component vuln
          title: 'Duplicate Vulnerability',
          severity: 'HIGH',
          status: 'open',
          packageName: 'test-package',
          versionRange: '1.0.0',
          publishedAt: '2023-01-01',
          referenceUrl: 'https://example.com/vuln-1',
        },
      ];

      (mockGraphQLClient.query as any)
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: componentVulns,
            },
          },
        })
        .mockResolvedValueOnce({
          data: {
            vulnerabilities: {
              items: repoVulns,
            },
          },
        });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1', 'repo-1');

      expect(result).toHaveLength(1);
      expect(result[0].id).toBe('vuln-1');
    });

    it('should handle empty results', async () => {
      (mockGraphQLClient.query as any).mockResolvedValue({
        data: {
          vulnerabilities: {
            items: [],
          },
        },
      });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1', 'repo-1');

      expect(result).toHaveLength(0);
    });

    it('should respect maxItems limit', async () => {
      const manyVulns = Array.from({ length: 150 }, (_, i) => ({
        id: `vuln-${i}`,
        title: `Vulnerability ${i}`,
        severity: 'HIGH',
        status: 'open',
        packageName: 'test-package',
        versionRange: '1.0.0',
        publishedAt: '2023-01-01',
        referenceUrl: 'https://example.com/vuln',
      }));

      (mockGraphQLClient.query as any).mockResolvedValue({
        data: {
          vulnerabilities: {
            items: manyVulns,
          },
        },
      });

      const result = await vulnerabilityService.fetchVulnerabilities('component-1');

      expect(result).toHaveLength(100); // Should be limited to maxItems
    });
  });
});
