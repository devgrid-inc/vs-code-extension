import { ApiError } from '../errors/DevGridError';
import type { IGraphQLClient } from '../interfaces/IGraphQLClient';
import type { ILogger } from '../interfaces/ILogger';
import type { DevGridVulnerability, DevGridVulnerabilityDetails } from '../types';

/**
 * GraphQL response interfaces
 */
interface GraphVulnerability {
  id?: string | null;
  name?: string | null;
  severity?: string | null;
  status?: string | null;
  packageName?: string | null;
  versionRange?: string | null;
  publishedAt?: string | null;
  referenceUrl?: string | null;
}

interface EntityVulnerabilitiesResponse {
  vulnerabilities?: {
    items?: Array<GraphVulnerability | null> | null;
  } | null;
}

interface VulnerabilityDetailsResponse {
  vulnerabilityIdentifier?: {
    id?: string | null;
    externalSource?: string | null;
    externalId?: string | null;
    externalUrl?: string | null;
    externalName?: string | null;
    externalDescription?: string | null;
    publishedDate?: string | null;
    cvssScore?: number | null;
    vectorString?: string | null;
    references?: any | null;
  } | null;
  vulnerability?: {
    id?: string | null;
    name?: string | null;
    description?: string | null;
    severity?: string | null;
    status?: string | null;
    identifiers?: Array<{
      id?: string | null;
      externalSource?: string | null;
      externalId?: string | null;
      externalUrl?: string | null;
      externalName?: string | null;
      externalDescription?: string | null;
      publishedDate?: string | null;
      cvssScore?: number | null;
      vectorString?: string | null;
      references?: any | null;
      epssScore?: number | null;
      impactScore?: number | null;
      exploitabilityScore?: number | null;
      attackVector?: string | null;
      attackComplexity?: string | null;
      weaknesses?: any | null;
      metrics?: any | null;
    } | null> | null;
    originatingSystem?: string | null;
    originatingSystemId?: string | null;
    scanType?: string | null;
    location?: string | null;
    attributes?: Record<string, unknown> | null;
    openDate?: string | null;
    closeDate?: string | null;
    vulnerableId?: string | null;
    vulnerableType?: string | null;
    originatingSystemUrl?: string | null;
  } | null;
}

/**
 * Vulnerability service for DevGrid vulnerabilities
 */
export class VulnerabilityService {
  private cache = new Map<string, { data: DevGridVulnerabilityDetails; timestamp: number }>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  // eslint-disable-next-line no-useless-constructor -- TypeScript parameter properties for dependency injection
  constructor(
    private graphqlClient: IGraphQLClient,
    private logger: ILogger,
    private maxItems: number
  ) {}

  /**
   * Fetches vulnerabilities for component and/or repository
   */
  async fetchVulnerabilities(
    componentId?: string,
    repositoryId?: string
  ): Promise<DevGridVulnerability[]> {
    this.logger.debug('Fetching vulnerabilities', {
      componentId: componentId ?? '(none)',
      repositoryId: repositoryId ?? '(none)',
    });

    const allVulnerabilities: DevGridVulnerability[] = [];
    const seenIds = new Set<string>();

    if (componentId) {
      this.logger.debug('Searching by componentId', { componentId });
      const componentVulns = await this.fetchVulnerabilitiesByVulnerableId(componentId);
      for (const vuln of componentVulns) {
        if (!seenIds.has(vuln.id)) {
          seenIds.add(vuln.id);
          allVulnerabilities.push(vuln);
        }
      }
    }

    if (repositoryId) {
      this.logger.debug('Searching by repositoryId', { repositoryId });
      const repoVulns = await this.fetchVulnerabilitiesByVulnerableId(repositoryId);
      for (const vuln of repoVulns) {
        if (!seenIds.has(vuln.id)) {
          seenIds.add(vuln.id);
          allVulnerabilities.push(vuln);
        }
      }
    }

    this.logger.debug('Found unique vulnerabilities', {
      count: allVulnerabilities.length,
      componentId: componentId ? '✓' : '✗',
      repositoryId: repositoryId ? '✓' : '✗',
    });

    return allVulnerabilities.slice(0, this.maxItems);
  }

  /**
   * Fetches vulnerabilities by vulnerable ID
   */
  private async fetchVulnerabilitiesByVulnerableId(
    vulnerableId: string
  ): Promise<DevGridVulnerability[]> {
    try {
      const data = await this.graphqlClient.query<EntityVulnerabilitiesResponse>(
        `
          query EntityVulnerabilities($vulnerableId: ID!, $limit: Int!) {
            vulnerabilities(filter: { vulnerableId: $vulnerableId }, pagination: { limit: $limit }) {
              items {
                id
                name
                severity
                status
                packageName
                versionRange
                publishedAt
                referenceUrl
              }
            }
          }
        `,
        {
          vulnerableId,
          limit: this.maxItems,
        }
      );

      const vulnerabilities = data.data?.vulnerabilities?.items ?? [];
      const result: DevGridVulnerability[] = [];

      for (const item of vulnerabilities) {
        this.logger.debug('Processing vulnerability item', {
          id: item?.id,
          name: item?.name,
          severity: item?.severity,
          vulnerableId,
        });

        if (!item?.id || !item.name || !item.severity) {
          this.logger.debug('Skipping invalid vulnerability item', { item });
          continue;
        }

        result.push({
          id: item.id,
          title: item.name,
          severity: item.severity,
          status: item.status ?? undefined,
          packageName: item.packageName ?? undefined,
          versionRange: item.versionRange ?? undefined,
          publishedAt: item.publishedAt ?? undefined,
          referenceUrl: item.referenceUrl ?? undefined,
        });
      }

      this.logger.debug('Fetched vulnerabilities by vulnerableId', {
        vulnerableId,
        count: result.length,
      });

      return result;
    } catch (error) {
      this.logger.error('Failed to fetch vulnerabilities by vulnerableId', error as Error, {
        vulnerableId,
      });
      throw new ApiError('Failed to fetch vulnerabilities', {
        vulnerableId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Fetches detailed vulnerability information by ID
   */
  async fetchVulnerabilityDetails(id: string): Promise<DevGridVulnerabilityDetails | undefined> {
    this.logger.info('fetchVulnerabilityDetails called', { id, idType: typeof id, idValue: id });

    // Check cache first
    const cached = this.cache.get(id);
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      this.logger.debug('Returning cached vulnerability details', { id });
      return cached.data;
    }

    try {
      // Query vulnerability directly using the provided GraphQL query
      const data = await this.graphqlClient.query<VulnerabilityDetailsResponse>(
        `
          query Vulnerability($id: ID!) {
            vulnerability(id: $id) {
              id
              name
              description
              originatingSystem
              originatingSystemId
              originatingSystemUrl
              scanType
              severity
              status
              location
              attributes
              openDate
              closeDate
              vulnerableId
              vulnerableType
              identifiers {
                id
                externalSource
                externalId
                externalUrl
                externalName
                externalDescription
                publishedDate
                epssScore
                cvssScore
                impactScore
                exploitabilityScore
                attackVector
                vectorString
                attackComplexity
                references
                metrics
                weaknesses
              }
            }
          }
        `,
        { id }
      );

      this.logger.info('Vulnerability query response', {
        id,
        hasData: !!data.data,
        hasVulnerability: !!data.data?.vulnerability,
        vulnerabilityId: data.data?.vulnerability?.id,
        vulnerabilityName: data.data?.vulnerability?.name,
        severity: data.data?.vulnerability?.severity,
        identifierCount: data.data?.vulnerability?.identifiers?.length,
      });

      const vulnerability = data.data?.vulnerability;

      if (!vulnerability) {
        this.logger.info('Vulnerability not found', { id });
        return undefined;
      }

      if (!vulnerability.id || !vulnerability.name) {
        this.logger.warn('Invalid vulnerability data received', { id });
        return undefined;
      }

      const rawIdentifiers =
        vulnerability.identifiers?.filter(
          (ident): ident is NonNullable<(typeof vulnerability.identifiers)[number]> => ident !== null
        ) ?? [];

      const normalizedIdentifiers = rawIdentifiers
        .filter((ident) => typeof ident.externalId === 'string' && ident.externalId.trim().length > 0)
        .map((ident) => ({
          type: ident.externalSource || 'unknown',
          value: ident.externalId!.trim(),
          url: ident.externalUrl ?? undefined,
          name: ident.externalName ?? undefined,
          description: ident.externalDescription ?? undefined,
          publishedDate: ident.publishedDate ?? undefined,
          cvssScore: ident.cvssScore ?? undefined,
          vectorString: ident.vectorString ?? undefined,
          epssScore: ident.epssScore ?? undefined,
          impactScore: ident.impactScore ?? undefined,
          exploitabilityScore: ident.exploitabilityScore ?? undefined,
          attackVector: ident.attackVector ?? undefined,
          attackComplexity: ident.attackComplexity ?? undefined,
          weaknesses: Array.isArray(ident.weaknesses)
            ? ident.weaknesses.filter((value): value is string => typeof value === 'string' && value.length > 0)
            : undefined,
          references: ident.references ?? undefined,
          metrics: ident.metrics ?? undefined,
        }));

      const primaryIdentifier = normalizedIdentifiers[0] ?? null;

      // Map Vulnerability to DevGridVulnerabilityDetails
      const details: DevGridVulnerabilityDetails = {
        id: vulnerability.id,
        title: vulnerability.name,
        severity: vulnerability.severity || 'unknown',
        status: vulnerability.status ?? undefined,
        packageName: undefined,
        versionRange: undefined,
        publishedAt: primaryIdentifier?.publishedDate ?? undefined,
        referenceUrl:
          vulnerability.originatingSystemUrl ?? primaryIdentifier?.url ?? undefined,
        identifiers: normalizedIdentifiers,
        cvss: primaryIdentifier?.cvssScore
          ? {
              baseScore: primaryIdentifier.cvssScore,
              vector: primaryIdentifier.vectorString ?? undefined,
            }
          : undefined,
        description:
          vulnerability.description ?? primaryIdentifier?.description ?? undefined,
        remediation: undefined,
        references: [],
        originatingSystem: vulnerability.originatingSystem ?? undefined,
        originatingSystemId: vulnerability.originatingSystemId ?? undefined,
        originatingSystemUrl: vulnerability.originatingSystemUrl ?? undefined,
        scanType: vulnerability.scanType ?? undefined,
        location: vulnerability.location ?? undefined,
        openDate: vulnerability.openDate ?? undefined,
        closeDate: vulnerability.closeDate ?? undefined,
        vulnerableId: vulnerability.vulnerableId ?? undefined,
        vulnerableType: vulnerability.vulnerableType ?? undefined,
        attributes: vulnerability.attributes ?? undefined,
      };

      // Cache the result
      this.cache.set(id, { data: details, timestamp: Date.now() });

      this.logger.info('Fetched vulnerability details from Vulnerability query', {
        id,
        title: details.title,
        severity: details.severity,
        identifierCount: details.identifiers?.length ?? 0,
        hasCVSS: !!details.cvss,
        hasDescription: !!details.description,
      });

      return details;
    } catch (error) {
      this.logger.error('Failed to fetch vulnerability details', error as Error, { id });
      throw new ApiError('Failed to fetch vulnerability details', {
        id,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }
}
