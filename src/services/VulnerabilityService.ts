import type { ILogger } from '../interfaces/ILogger';
import type { IGraphQLClient } from '../interfaces/IGraphQLClient';
import type { DevGridVulnerability } from '../types';
import { ApiError } from '../errors/DevGridError';

/**
 * GraphQL response interfaces
 */
interface GraphVulnerability {
  id?: string | null;
  title?: string | null;
  severity?: string | null;
  status?: string | null;
  packageName?: string | null;
  versionRange?: string | null;
  publishedAt?: string | null;
  referenceUrl?: string | null;
}

interface EntityVulnerabilitiesResponse {
  vulnerabilities?: {
    items?: Array<GraphVulnerability | null> | null;
  } | null;
}

/**
 * Vulnerability service for DevGrid vulnerabilities
 */
export class VulnerabilityService {
  constructor(
    private graphqlClient: IGraphQLClient,
    private logger: ILogger,
    private maxItems: number
  ) {}

  /**
   * Fetches vulnerabilities for component and/or repository
   */
  async fetchVulnerabilities(
    componentId?: string,
    repositoryId?: string
  ): Promise<DevGridVulnerability[]> {
    this.logger.debug('Fetching vulnerabilities', {
      componentId: componentId ?? '(none)',
      repositoryId: repositoryId ?? '(none)',
    });

    const allVulnerabilities: DevGridVulnerability[] = [];
    const seenIds = new Set<string>();

    if (componentId) {
      this.logger.debug('Searching by componentId', { componentId });
      const componentVulns = await this.fetchVulnerabilitiesByVulnerableId(componentId);
      for (const vuln of componentVulns) {
        if (!seenIds.has(vuln.id)) {
          seenIds.add(vuln.id);
          allVulnerabilities.push(vuln);
        }
      }
    }

    if (repositoryId) {
      this.logger.debug('Searching by repositoryId', { repositoryId });
      const repoVulns = await this.fetchVulnerabilitiesByVulnerableId(repositoryId);
      for (const vuln of repoVulns) {
        if (!seenIds.has(vuln.id)) {
          seenIds.add(vuln.id);
          allVulnerabilities.push(vuln);
        }
      }
    }

    this.logger.debug('Found unique vulnerabilities', {
      count: allVulnerabilities.length,
      componentId: componentId ? '✓' : '✗',
      repositoryId: repositoryId ? '✓' : '✗',
    });

    return allVulnerabilities.slice(0, this.maxItems);
  }

  /**
   * Fetches vulnerabilities by vulnerable ID
   */
  private async fetchVulnerabilitiesByVulnerableId(
    vulnerableId: string
  ): Promise<DevGridVulnerability[]> {
    try {
      const data = await this.graphqlClient.query<EntityVulnerabilitiesResponse>(
        `
          query EntityVulnerabilities($vulnerableId: ID!, $limit: Int!) {
            vulnerabilities(filter: { vulnerableId: $vulnerableId }, pagination: { limit: $limit }) {
              items {
                id
                title
                severity
                status
                packageName
                versionRange
                publishedAt
                referenceUrl
              }
            }
          }
        `,
        {
          vulnerableId,
          limit: this.maxItems,
        }
      );

      const vulnerabilities = data.data?.vulnerabilities?.items ?? [];
      const result: DevGridVulnerability[] = [];

      for (const item of vulnerabilities) {
        if (!item?.id || !item.title || !item.severity) {
          continue;
        }

        result.push({
          id: item.id,
          title: item.title,
          severity: item.severity,
          status: item.status ?? undefined,
          packageName: item.packageName ?? undefined,
          versionRange: item.versionRange ?? undefined,
          publishedAt: item.publishedAt ?? undefined,
          referenceUrl: item.referenceUrl ?? undefined,
        });
      }

      this.logger.debug('Fetched vulnerabilities by vulnerableId', {
        vulnerableId,
        count: result.length,
      });

      return result;
    } catch (error) {
      this.logger.error('Failed to fetch vulnerabilities by vulnerableId', error as Error, {
        vulnerableId,
      });
      throw new ApiError('Failed to fetch vulnerabilities', {
        vulnerableId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }
}
